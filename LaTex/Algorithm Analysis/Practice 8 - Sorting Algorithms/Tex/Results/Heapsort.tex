\subsection{Heap-Sort Algorithm:}

First test of {\bfseries Heap-Sort} algorithm. The program will plot the time that the algorithm takes to sort three lists of size {\itshape n = 10}. The first list will have the elements already sorted, the second will have the elements in random order, and the third list will have the elements sorted but in decreasing order. With this we will corroborate the complexity of this algorithm presented in section 2. Each list represents its {\itshape best, random and worst} case. \hfill \break

\begin{figure}[H]
\includegraphics[width = 16.5cm, height = 8cm]{Heap-output-10.png}
\centering \linebreak \linebreak {\small Figure 4.1.0: Heap-Sort console output.}
\end{figure} 

\begin{figure}[H]
\includegraphics[width = 16.5cm, height = 8cm]{Heap-10.png}
\centering \linebreak \linebreak {\small Figure 4.1.1: Heap-Sort graph for the lists in Figure 4.1.0.}
\end{figure} \pagebreak

Table 1 illustrate the plotting points of Figure 4.1.1 graphs, the first column represents the size of the list to sort, the second, third and fourth, the time that takes to sort that list in its best, random and worst case of the algorithm. \hfill \break

{\small
\begin{center} 
\begin{tabular}[.5cm]{ c c c c } 
\toprule \toprule
\hspace {5px} Size ( n ) \hspace {5px} & \hspace {15px} Best Case Time ( t ) \hspace {15px} & \hspace {15px} Random Case Time ( t ) \hspace {15px} & \hspace {15px} Worst Case Time ( t ) \hspace {15px} \\ 
\midrule \midrule
2 & 44 & 33 & 33 \\ 
\cmidrule {1-4} 
3 & 73 & 61 & 61 \\ 
\cmidrule {1-4} 
4 & 123 & 89 & 78 \\ 
\cmidrule {1-4} 
5 & 152 & 118 & 129 \\ 
\cmidrule {1-4} 
6 & 203 & 157 & 146 \\ 
\cmidrule {1-4} 
7 & 233 & 208 & 174 \\ 
\cmidrule {1-4} 
8 & 305 & 225 & 236 \\ 
\cmidrule {1-4} 
9 & 357 & 264 & 287 \\ 
\cmidrule {1-4} 
10 & 407 & 326 & 304 \\ 
\bottomrule 
\linebreak 
\end{tabular} 
\linebreak \linebreak Table 1.
\end{center}}

{\bfseries\itshape\color{carmine}{Observation:}} {\itshape\color{carmine}{In Figure 4.1.1 there are 3 graphs, the one on the left represent the algorithm's best case, analogously the middle and right ones represents the random and worst case, in each graph, there is a {\bfseries pointed} stroke, this it's an asymptotic function for the main plot.}}

\pagebreak

Second test of {\bfseries Heap-Sort} algorithm. The program will plot the time that the algorithm takes to sort three lists of size {\itshape n = 20}. The first list will have the elements already sorted, the second will have the elements in random order, and the third list will have the elements sorted but in decreasing order. With this we will corroborate the complexity of this algorithm presented in section 2. Each list represents its {\itshape best, random and worst} case. \hfill \break

\begin{figure}[H]
\includegraphics[width = 16.5cm, height = 8cm]{Heap-output-20.png}
\centering \linebreak \linebreak {\small Figure 4.1.2: Heap-Sort console output.}
\end{figure}

\begin{figure}[H]
\includegraphics[width = 16.5cm, height = 8cm]{Heap-20.png}
\centering \linebreak \linebreak {\small Figure 4.1.3: Heap-Sort graph for the lists in Figure 4.1.2.}
\end{figure} \pagebreak

Table 2 illustrate the plotting points of Figure 4.1.3 graphs, the first column represents the size of the list to sort, the second, third and fourth, the time that takes to sort that list in its best, random and worst case of the algorithm. \hfill \break

{\small
\begin{center} 
\begin{tabular}[.5cm]{ c c c c } 
\toprule 
\hspace {5px} Size ( n ) \hspace {5px} & \hspace {15px} Best Case Time ( t ) \hspace {15px} & \hspace {15px} Random Case Time ( t ) \hspace {15px} & \hspace {15px} Worst Case Time ( t ) \hspace {15px} \\ \midrule 
2 & 44 & 44 & 33 \\ 
\cmidrule {1-4} 
3 & 73 & 72 & 61 \\ 
\cmidrule {1-4} 
4 & 123 & 100 & 78 \\ 
\cmidrule {1-4} 
5 & 152 & 150 & 129 \\ 
\cmidrule {1-4} 
6 & 203 & 190 & 146 \\ 
\cmidrule {1-4} 
7 & 233 & 244 & 174 \\ 
\cmidrule {1-4} 
8 & 305 & 283 & 236 \\ 
\cmidrule {1-4} 
9 & 357 & 356 & 287 \\ 
\cmidrule {1-4} 
10 & 407 & 407 & 304 \\ 
\cmidrule {1-4} 
11 & 460 & 446 & 332 \\ 
\cmidrule {1-4} 
12 & 533 & 474 & 395 \\ 
\cmidrule {1-4} 
13 & 586 & 549 & 468 \\ 
\cmidrule {1-4} 
14 & 637 & 624 & 485 \\ 
\cmidrule {1-4} 
15 & 691 & 652 & 536 \\ 
\cmidrule {1-4} 
16 & 762 & 714 & 576 \\ 
\cmidrule {1-4} 
17 & 836 & 776 & 625 \\ 
\cmidrule {1-4} 
18 & 910 & 850 & 688 \\ 
\cmidrule {1-4} 
19 & 962 & 902 & 763 \\ 
\cmidrule {1-4} 
20 & 1036 & 907 & 826 \\ 
\bottomrule 
\linebreak 
\end{tabular} 
\linebreak \linebreak Table 2.
\end{center}}

\pagebreak

Our last test for this algorithm consist in plotting the complexity of lists of sizes {\itshape n = 500} and {\itshape n = 1000} as we can see in Figures 4.1.4 and 4.1.5 respectively. In this examples we can visualize clearly that the algorithm in its best, random or worst case always will be {\bfseries $\mathcal{O}(n\log{}n)$} time. \hfill \break

\begin{figure}[H]
\includegraphics[width = 16.5cm, height = 8cm]{Heap-500.png}
\centering \linebreak \linebreak {\small Figure 4.1.4: Heap-Sort complexity for lists of size n = 500.}
\end{figure}

\begin{figure}[H]
\includegraphics[width = 16.5cm, height = 8cm]{Heap-1000.png}
\centering \linebreak \linebreak {\small Figure 4.1.5: Heap-Sort complexity for lists of size n = 1000.}
\end{figure}

\pagebreak